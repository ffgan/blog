# 记参与开源之夏的尝试

## 0. 前言+可能被问到的问题

本篇blog将会围绕2025年本人申请开源之夏项目的历程持续记录. 基本形式为按照时间格式来进行记录。即使有可能会申请失败，但仍然希望能对后来者有所帮助。

以下事先回答几个有可能被问到的问题：

### 1. 为什么写本篇blog？

当作学习笔记，记录对开源的一个尝试。通过这篇blog来记录下初学者的开源入门之旅。在这里将要去尝试学习一个开源项目，尝试去为项目提有意义的issue、提合格的PR，同时尝试去申请开源之夏项目，即使可能会失败，这个过程仍然是有意义的。

### 2. 这篇blog为什么要在尝试的开始前就写？不应该取得了成果之后再来谈如何取得成果嘛？

我希望尽可能的把这个尝试的过程给全部公开出来，并期待得到更多的指导来纠正改进。

## 1. 开源之夏

> 开源之夏是中国科学院软件研究所发起的“开源软件供应链点亮计划”系列暑期活动，旨在鼓励高校学生积极参与开源软件的开发维护，培养和发掘更多优秀的开发者，促进优秀开源软件社区的蓬勃发展，助力开源软件供应链建设。开源之夏于2020年正式发起，当前活动是第六届。
>
>活动联合各大开源社区，针对重要开源软件的开发与维护提供项目开发任务，并向全球高校学生开放报名。学生可自主选择感兴趣的项目进行申请，中选后在项目开发者（社区导师）的指导下进行开发。根据项目的难易程度和完成情况，结项者将获取开源之夏活动劳务报酬和结项证书。

官网：[链接](https://summer-ospp.ac.cn/)

最早在逛[v2ex](https://www.v2ex.com/)的时候了解到的开源之夏，有帖子介绍了大概内容，于是就开始关注并希望能参与进开源之夏这个活动。参加该活动的主要目的是能以一种更加友好的方式加入开源社区，认识更多同样热爱开源的朋友。

要参加一个活动，首先要了解这个活动，按照是什么、为什么、怎么做三部曲来走。

### 1. 是什么

刚才开篇已经介绍了开源之夏。现在来更进一步了解。翻阅其官网，有一个参考指南，里面有两个链接

1. [学生指南](https://blog.summer-ospp.ac.cn/help/student%20guide)
2. [热点问题](https://blog.summer-ospp.ac.cn/help/FAQ)

按照惯例应该先读完学生指南这类详细的长文档，然后总结一波，看看有啥疑问。最后再去看热点问题（FAQ），FAQ的作用也正是如此。

那么就按照流程来走，先翻阅学生指南，然后翻阅FAQ。

结合学生指南和热点问题，可以得知以下几点：

1. 每个项目均有一名提供指导建议的导师，需要积极和导师进行沟通。
2. 项目需要由学生主动申请，编写申请书。可能有多个学生共同申请同一个项目，最终只能有一个学生中选。
3. 一个学生仅能申请一个项目，申请成功后仅能由学生单人完成设计、开发等工作。
4. 有明确的活动时间周期，在合适的周期内完成对应的工作。
5. 项目按照难度区分为基础和进阶，如果申请成功并顺利完成开发以及通过结项审核会获得劳动报酬。

依照活动时间周期来看，有两个关键时间周期，需要特别注意相对应的截至时间。
> 04/04-05/09 项目任务发布阶段 通过审核的项目任务将陆续上线官网，学生可以通过项目详情的导师邮箱与导师进行沟通。
>
> 05/09-06/09 学生报名活动、提交申请书。学生挑选项目，与导师沟通并准备项目申请材料、提交项目申请，每位同学可以申请一个项目。
>
> 04/30 起，学生可在系统注册账号并填写个人资料提交审核。资料审核通过的学生 05/09 起可在系统提交项目申请书。 截止时间：06/09 18:00 UTC+8

中选的重要依据是申请书，申请书需要清晰的列出对该项目的技术方案、开发时间规划，避免阐述过于细枝末节的源码实现。除此之外还需要准备一份学生简历，以便导师快速了解申请者的背景来历。

### 2. 为什么

为什么要参加开源之夏？

1. 支持开源活动，为开源做贡献
2. 提升coding能力以及学习更多code以外的知识，其中最重要的当属沟通和文档能力
3. 结识更多热爱开源的伙伴，积极参与社区，为成为社区一份子准备。（社区的力量远比想象的要强大）

### 3. 怎么做

现在（date -> Fri Apr 18 11:28:36 PM +08 2025）短期内的主要工作为寻找自己感兴趣的项目，然后去了解项目并尝试阅读项目源码，在此基础上查看项目要求，再去积极和导师沟通，了解更多有关项目的信息。

### 4. 总结

了解完开源之夏的背景知识之后，不难得出以下两点关键

1. 寻找到合适的项目，对项目进行足够多的了解与学习
2. 编写高质量的申请书

## 2. 实操阶段

上面这些内容通过翻阅开源官方文档即可总结得到。下面就要使用理论来指导实践，依葫芦画瓢即可。

### 1. 寻找到合适的项目

这里可能就没有太多能够借鉴和参考的章节。项目是面向具体方向、具体需求场景的，适合某些人开发的项目不一定适合另外一些人。

[项目列表](https://summer-ospp.ac.cn/org/projectlist?lang=zh&pageNum=1&pageSize=50)

里面列出各个不同的技术领域、不同的编程语言、不同的社区，按需查找自己感兴趣的项目即可。

以下我就来说说我所听说过的一些领域，站在一个普通的带学生视角。

比如说大数据领域，我仅仅只是听说过一些。

数据库无法体现数据的历史变化，但是这些历史变化什么的、以及运行过程产生的日志什么的，数据之间的关系，都是有价值的，于是需要整点数据挖掘，建立数据仓库、数据湖,搞离线在线实时分析什么的。听说过一些什么flink、spark、Hadoop等框架，什么clickhouse、elastic search。当然其中最出名的还是那个Google 11级传说Jeff Dean的Map Reduce模型，从fp得到灵感而来的，map分发任务，reduce收集结果什么的。然后这个大数据往往都会融合点机器学习，搞点用户画像，玩个性化推荐。前不久抖音刚公开其视频推荐算法，[链接](https://95152.douyin.com/)。对了，说到日志处理这块，最近也有遇到和使用相关的一些内容。

密码学领域就不太熟悉了，至于我了解的程度可以在我另外一篇blog [遇事不决](../遇事不决/pqc.md) 中可以看到。

别的领域就先不提了，目前我比较倾向于云原生方向，往k8s生态靠。

k8s目前对我来说，接触的不算太多。

对于容器管理，最早我在docker compose用来部署和管理小规模下的docker容器，比如说部署个简单的后端服务，配个valkey(redis的一个fork)+pgsql+mongoDB+后端服务，写写docker-compose.yml，再配置一下持久化、端口映射这些就够用了。

（不多说了，直接学习新项目，这部分内容后面再补充了）

### 2. 学习目标项目及其相关背景知识

经过一顿操作，暂定本次申请的项目为 [基于RISC-V架构的KubeVirt虚拟化支持与生态适配](https://summer-ospp.ac.cn/org/prodetail/25a190083?lang=zh&list=pro)

首先查看项目的基本情况介绍以及项目待完成工作

**项目简介**

> 随着 RISC-V 架构在开源硬件领域的迅速发展，其在 AI 推理/训练和视频编解码等高性能计算场景中的应用潜力日益凸显。为了充分利用 RISC-V 的优势，构建支持分布式虚拟化直通的解决方案变得尤为重要。KubeVirt 作为 Kubernetes 的虚拟化扩展，为容器化环境中的虚拟机管理提供了强大的支持。然而，目前 KubeVirt 尚未原生支持 RISC-V 架构，这限制了其在新兴硬件平台上的应用。
目前，已实现了在 RISC-V 上重构基本的容器镜像，并且构建工具链已适配 RISC-V 架构 。本项目旨在深入探索 RISC-V 的虚拟化特性，特别是结合 QEMU 和 KVM 的支持，完善 KubeVirt 在 RISC-V 上的适配工作。具体包括：实现对 RISC-V 虚拟化扩展的支持、提供分布式虚拟化直通的能力、确保与现有社区生态的兼容性等。
通过本项目的实施，期望将 RISC-V 的支持合并到 KubeVirt 的上游社区，推动其在新兴硬件平台上的应用。这不仅有助于推动在云原生虚拟化领域的影响力，也为 AI 推理/训练和视频编解码等高性能计算场景提供坚实的基础。

**项目目标产出**

1. 为 KubeVirt 提供 RISC-V 虚拟机创建和直通支持
2. 为 Kubevirt RISC-V 支持开发虚拟化验证测试用例
3. 为上游社区合并提供自动化验证能力
4. 为适配方案编写技术文档与用户指南

**项目技术要求**

1. 掌握 Golang，能理解和修改 KubeVirt 代码；
2. 熟练使用 Shell 脚本进行环境配置与调试
3. 了解 Python，用于测试脚本与自动化工具
4. 熟悉 YAML/JSON 配置格式及基本语法

其他内容暂时还没有发现，那就先基于这些信息来分析一波。

RISC-V架构是开源的一个精简指令集架构。指令集架构主要分为两种设计方向，RISC和CISC，精简VS复杂，各有优缺点，RISC能简化CPU设计、利于编译器做优化，CISC感觉上运行会更快？（硬件实现的指令自然会比软件实现的指令要快）。CISC比较主流的有x86（x86一般32位比较多。现在更多是64位的，也叫x86-64,叫x64也行），常见的pc机都是x86的。RISC的话比较多的是ARM架构，手机基本都是ARM的，mac的m系也是arm架构的。

国产的话，目前在搞的信创活动，也有挺多在琢磨指令集方向的，比较出名的应该是LoongArch。值得一提的是，阿里搞了个香山处理器，据称性能不错，用的正是RISC-V指令集。

话说回来，如果仅仅只是用高级语言来编程，比如说Go，其实指令集、OS之类的是透明的，这个都依靠编译器来提供交叉编译能力，而且对各个平台的支持大多都是由Go官方团队来提供支持的，个人去开发的话，难度还是不小的。回到本项目上，要掌握RISC-V指令集到什么程度还有待进一步琢磨。

指令集这个暂时就先搁置，后来再来看看需要做什么。

那么下一个需要琢磨就是kubevirt项目本身了。kube开头的，经典属于k8s生态。配了一个virt，说实话初看是有点疑惑的。k8s本身是用来部署和管理容器，而容器、虚拟机这些的概念就没啥必要再提了。需要提的就是同一个机器上的多个容器是共享同一个内核的，有兴趣的可以试着起多个容器然后exec进去，执行一下unmae -a看看就可以了。

简单搜索一下就可以得到kubevirt的有关信息

[官网](https://kubevirt.io/)

[Github Repo](https://github.com/kubevirt/kubevirt)

管它三七二十一，本地起手就是一个部署看看能不能跑。部署方式挺多，就用最容易的minikube。参考这个[链接](https://kubevirt.io/quickstart_minikube/)

具体部署流程和发行版有关。目前我在使用的为fedora，试了一下podman不太行，和minikube搭配有问题。

以下是一个基本部署流程，请确保全程处于科学上网环境

1. 安装docker

```shell
sudo dnf install docker -y
sudo systemctl enable docker
sudo systemctl start docker
```

2. 安装minikube

```shell
curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-latest.x86_64.rpm
sudo rpm -Uvh minikube-latest.x86_64.rpm
```

3. 安装kubectl

```shell
sudo dnf install kubernetes1.32 kubernetes1.32-kubeadm kubernetes1.32-client
```

4. 启动minikube

```shell
minikube start
```

如果启动不了，大概率是拉image拉不动，配一下网络环境就好

5. 打开minikube dashboard

minikube自带了一个还不错的dashboard，可以一键启动

```shell
minikube dashboard
```

启动会有一些慢，请耐心等待，在启动完之后会自动打开管理界面（如果是处于linux GUI下）。

点击dashboard右上角的 + ，试着启动一个pod看看如何

```yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  selector:
    matchLabels:
      app: nginx
  replicas: 3
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:alpine
        ports:
        - containerPort: 80
```

稍等片刻就能起来。

![](images/1746288506982_image.png)

点击这里的exec就可以进入到容器内，还是挺方便的。

```shell
netstat -lntp | grep 80 # 查看80端口是否被占用
```

![alt text](images/1746288555709_image.png)

以上步骤一切正常说明minikube能正常工作。

按照kubevirt里的minikube使用示例，启动minikube时需要配一下CNI（container network interface），同时为了方便demo学习，加多一个参数nodes来模拟多个node的情况

```shell
# minikube delete # 删掉之前的cluster实例，如果有
minikube start --nodes=2 --cni=flannel
```

使用以下命令来部署KubeVirt operator，用来管理kubevirt核心组件的生命周期

```shell
export VERSION=$(curl -s https://storage.googleapis.com/kubevirt-prow/release/kubevirt/kubevirt/stable.txt)
echo $VERSION
kubectl create -f "https://github.com/kubevirt/kubevirt/releases/download/${VERSION}/kubevirt-operator.yaml"
```

```shell
# 部署kubevirt
kubectl create -f "https://github.com/kubevirt/kubevirt/releases/download/${VERSION}/kubevirt-cr.yaml"
# 检查是否部署成功，出现Deployed则表示成功部署，如果是Deploying就耐心等等
kubectl get kubevirt.kubevirt.io/kubevirt -n kubevirt -o=jsonpath="{.status.phase}"
```

由于VM比较特殊，kubevirt手册里说还要再装一个virtctl来管理VM。

```shell
VERSION=$(kubectl get kubevirt.kubevirt.io/kubevirt -n kubevirt -o=jsonpath="{.status.observedKubeVirtVersion}")
ARCH=$(uname -s | tr A-Z a-z)-$(uname -m | sed 's/x86_64/amd64/') || windows-amd64.exe
echo ${ARCH}
curl -L -o virtctl https://github.com/kubevirt/kubevirt/releases/download/${VERSION}/virtctl-${VERSION}-${ARCH}
# ps: 这里如果下不下来，直接去github release界面下就行
chmod +x virtctl
sudo install virtctl /usr/local/bin
```

接下来就是真正部署和使用VM了，就不展开了，比较简单。

进到VM里面看一眼内核
![alt text](images/1746331170595_image.png)

宿主机本身的话是这个
![alt text](images/1746331221502_image.png)

可以看到的确是创建了一个VM
