从递归说起，初学者无法理解的是一个函数调用自身，原因在于对于内存布局不了解。

以C语言为例，函数的调用需要依靠栈来实现，在临时停个车需要得到一个停车位，用完即归还。栈是内存当中的一块区域，由os划分给程序的。当调用函数时，需要把参数传递过去，或者说在执行该函数里的代码时需要有一种方式来获取到外部传递的信息，有的是通过寄存器传递参数，有的是通过栈来传递，还有的是通过放在堆上来全局共享。

初学者对于C当中函数的初印象不外乎是被花括号单独包裹起来的代码，学的深一点会知道有inline内联函数，整个程序的入口是main，main没有其他含义，通用惯例以main作为入口，整个程序开始的地方，如果main当中调用了其他函数，就会转移到对应函数执行。如printf，此时控制权交由printf，printf的执行也是需要依靠栈的，执行完之后再回收栈上的资源，控制权回到调用者main身上，从这里可以看出C当中不能返回普通的局部变量的原因，其内存地址是在栈上，函数调用完成后会被释放，再次引用该地址会造成无法想象的后果。

当被调函数中再去调用另外一个函数，此时就会构成一个调用链，main->f1->f2，以此类推，最后被调用的函数最先返回，按照数据结构中栈的顺序，先进后出完成调用。这里的理解是十分轻松，初学者也不会有太多的疑惑。
来到递归这里，情况就变得复杂了吗？main->f1->f1->f1...，上面的知识并没有失效，每次函数调用依旧会使用一个栈，区别在于传递进去的参数有可能不同，理解的核心在于，递归只是恰好调用了同一段代码，仅此而已。为了方便也可以写多个函数体相同的函数，f1->f2->f3...三者函数体相同，再按照常规的调用链来调用，而递归的魅力在于复用代码，只写一次，然后调用自身。显而易见的是，递归需要被结束，每次都调用自己而不到达一个界限，就会导致最常见的栈溢出问题，或者如Python里的抵达最大递归深度被强制终止。所以递归经常与下降合并一起称呼，递归下降。
现在再来理解阶乘的递归求法应该能很容易看出其中的写法了。f(3)->f(2)->f(1)，此时抵达最底层，1的阶乘为1，往往可以在递归函数的开头看到该if语句，此刻按照先进后出的顺序结束函数调用链。


