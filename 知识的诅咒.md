从递归说起，初学者无法理解的是一个函数调用自身，原因在于对于内存布局不了解。

以C语言为例，函数的调用需要依靠栈来实现。现实中临时停个车需要得到一个停车位，用完即归还，内存的分配与回收同理，需要申请然后使用，用完后被回收。栈是内存当中的一块区域，由os划分给程序的。当调用函数时，需要把参数传递过去，或者说在执行该函数里的代码时需要有一种方式来获取到外部传递的信息，有的是通过寄存器传递参数，有的是通过栈来传递，还有的是通过放在堆上来全局共享。

初学者对于C当中函数的初印象不外乎是被花括号单独包裹起来的代码，学的深一点会知道有inline内联函数，整个程序的入口是main，main没有其他含义，通用惯例以main作为入口，整个程序开始的地方，如果main当中调用了其他函数，需要为该函数分配内存空间，然后转移到对应函数执行。如printf，此时控制权交由printf，printf的执行也是需要依靠栈的，执行完之后再回收栈上的资源，控制权回到调用者main身上，从这里可以看出C当中不能返回普通的局部变量的原因，其内存地址是在栈上，函数调用完成后会被释放，再次引用该地址会造成无法想象的后果。（正如猜想中的一样，main的执行也需要占用内存空间）

当被调函数中再去调用另外一个函数，此时就会构成一个调用链，main->f1->f2，以此类推，最后被调用的函数最先返回，按照数据结构中栈的顺序，先进后出完成调用。这里的理解是十分轻松，初学者也不会有太多的疑惑。
来到递归这里，情况就变得复杂了吗？main->f1->f1->f1...，上面的知识并没有失效，每次函数调用依旧会使用一个栈，区别在于传递进去的参数有可能不同，理解的核心在于，递归只是恰好调用了同一段代码，仅此而已。为了方便也可以写多个函数体相同的函数，f1->f2->f3...三者函数体相同，再按照常规的调用链来调用，而递归的魅力在于复用代码，只写一次，然后调用自身。显而易见的是，递归需要被结束，每次都调用自己而不到达一个界限，就会导致最常见的栈溢出问题，或者如Python里的抵达最大递归深度被强制终止。所以递归经常与下降合并一起称呼，递归下降。

```c
#include <stdio.h>
int factorial(int n)
{
    if (n == 1)
    {
        return 1;
    }
    return n * factorial(n - 1);
}

int main()
{
    printf("%d\n", factorial(3));
    return 0;
}
```

现在来将其写成三个函数

```c
int factorial_1(int n)
{
    if (n == 1)
    {
        return 1;
    }
    //return n * factorial(n - 1);
}

int factorial_2(int n)
{
    if (n == 1)
    {
        return 1;
    }
    return n * factorial_1(n - 1);
}

int factorial_3(int n)
{
    if (n == 1)
    {
        return 1;
    }
    return n * factorial_2(n - 1);
}
```

一样能得出结果，但是代码其实是重复，而调用自身就是递归的魅力所在。

现在再来理解阶乘的递归求法应该能很容易看出其中的写法了。
1. f(3)->f(2)->f(1)，此时抵达最底层，1的阶乘为1,然后返回1。
2. 此时回到f(2)中，f(2)即为2 * factorial(2 - 1)，结果已经知道了，2 * 1 = 2,此时返回2。
3. 此时回到f(3)中，f(3) = 3 * f(2)，那么结果为3 * 2，所以最终结果为6;

往往可以在递归函数的开头看到一个if语句用来表达递归结束条件。

现在以[汉诺塔](https://zh.wikipedia.org/wiki/%E6%B1%89%E8%AF%BA%E5%A1%94)为例。
解决问题的思路如下:
1. 假设A上有n个盘子，只需要将A上的n-1个盘子移到B
2. 此时将A的最后一个盘子移到C
3. 最后再将B的n-1个盘子移到C，三步结束。

中间一步容易理解，而第一步和第三步恰好是同一个问题。那么就可以再次调用同一函数，只不过参数需要发生变化。以此可以很容易写出如下程序

```C
void hanoi(int n, char A, char B, char C)
{
    if (n == 1) //递归结束条件，只有一个的时候直接移动就行
    {
        move(A, C);
        return;
    }
    hanoi(n - 1, A, C, B); // 第一步
    move(A, C);            // 第二步
    hanoi(n - 1, B, A, C); // 第三步
}
```

知识的诅咒，理解知识的人无法想象不理解知识的人对于知识的理解。

上述的汉诺塔问题就是一个典型的例子，