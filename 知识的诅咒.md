从递归说起，初学者无法理解的是一个函数调用自身，原因在于对于内存布局不了解。

以C语言为例，函数的调用需要依靠栈来实现。在现实中临时停个车需要得到一个停车位，用完即归还，内存的分配与回收同理，需要申请然后使用，用完后被回收。栈是内存当中的一块区域，由os划分给程序的。当调用函数时，需要把参数传递过去，或者说在执行该函数里的代码时需要有一种方式来获取到外部传递的信息，有的是通过寄存器传递参数，有的是通过栈来传递，还有的是通过放在堆上来全局共享。获取到参数后函数就会开始执行，执行结束，到达了return语句，就会将返回结果返回至调用者处，释放被调用函数所占用的栈空间。

初学者对于C当中函数的初印象不外乎是被花括号单独包裹起来的代码段，学的深一点会知道有inline内联函数可以展开，其实这一点如果学过Pascal就会理解过程与函数的区别。整个程序的入口是main，main没有其他含义，通用惯例以main作为入口，整个程序开始的地方，如果main当中调用了其他函数，需要为该函数分配内存空间，然后转移到对应函数执行。如printf，此时控制权交由printf，printf的执行也是需要依靠栈的，执行完之后再回收栈上的资源，控制权回到调用者main身上，从这里可以看出C当中不能返回普通的局部变量的原因，其内存地址是在栈上，函数调用完成后会被释放，再次引用该地址会造成无法想象的后果。（正如猜想中的一样，main的执行也需要占用内存空间，也需要被调用）

当被调函数中再去调用另外一个函数，此时就会构成一个调用链，main->f1->f2，以此类推，最后被调用的函数最先返回，按照数据结构中栈的顺序，先进后出完成调用。这里的理解是十分轻松，初学者也不会有太多的疑惑。
来到递归这里，情况就变得复杂了吗？main->f1->f1->f1...，上面的知识并没有失效，每次函数调用依旧会使用一个栈，区别在于传递进去的参数有可能不同，理解的核心在于，递归只是恰好调用了同一段个函数，仅此而已。为了方便也可以写多个函数体相同的函数，f1->f2->f3...三者函数体相同，再按照常规的调用链来调用，而递归的魅力在于复用代码，只写一次，然后调用自身。显而易见的是，递归需要被结束，每次都调用自己而不到达一个界限，就会导致最常见的栈溢出问题，或者如Python里的抵达最大递归深度被强制终止。所以递归经常与下降合并一起称呼，递归下降。

```c
#include <stdio.h>
int factorial(int n)
{
    if (n == 1)
    {
        return 1;
    }
    return n * factorial(n - 1);
}

int main()
{
    printf("%d\n", factorial(3));
    return 0;
}
```

现在来将其写成三个函数

```c
int factorial_1(int n)
{
    if (n == 1)
    {
        return 1;
    }
    return n * factorial(n - 1);
}

int factorial_2(int n)
{
    if (n == 1)
    {
        return 1;
    }
    return n * factorial_1(n - 1);
}

int factorial_3(int n)
{
    if (n == 1)
    {
        return 1;
    }
    return n * factorial_2(n - 1);
}
```

一样能得出结果，但是代码段出现了重复，这种重复是不必要的。调用自身恰恰正是是递归的魅力所在。

现在再来理解阶乘的递归求法应该能很容易看出其中的写法了。
1. f(3)->f(2)->f(1)，此时抵达最底层，1的阶乘为1,然后返回1。
2. 此时回到f(2)中，f(2)即为2 * factorial(2 - 1)，结果已经知道了，2 * 1 = 2,此时返回2。
3. 此时回到f(3)中，f(3) = 3 * f(2)，那么结果为3 * 2，所以最终结果为6;

往往可以在递归函数的开头看到一个if语句用来表达递归结束条件。

再来举一个递归经典例子，以[汉诺塔](https://zh.wikipedia.org/wiki/%E6%B1%89%E8%AF%BA%E5%A1%94)为例。
解决问题的思路如下:
1. 假设A上有n个盘子，只需要将A上的n-1个盘子移到B
2. 此时将A的最后一个盘子移到C
3. 最后再将B的n-1个盘子移到C，三步结束。

`hanoi(n,A,B,C)`
这里的源柱子是A，目标柱子是C，中间柱子是B。

中间一步容易理解，而第一步和第三步恰好是同一个问题。那么就可以再次调用同一函数，只不过参数需要发生变化，首先是需要移动的盘子数减少了，然后这里理解的难点在于，交换了源柱子、中间柱子以及目标柱子。

来仔细分析第一步，第一步是希望将A上的n-1个盘子移动至B，那么源是A，目的是B，显然中间柱子是C。

因此第一步是`hanoi(n-1,A,C,B)`。

同理可得第三步，源是B，目标是C，中间是A，
因此第三步是`hanoi(n-1,B,A,C)`。

以上可以很容易写出如下程序

```C
void hanoi(int n, char A, char B, char C)
{
    if (n == 1) //递归结束条件，只有一个的时候直接移动就行
    {
        move(A, C);
        return;
    }
    hanoi(n - 1, A, C, B); // 第一步
    move(A, C);            // 第二步
    hanoi(n - 1, B, A, C); // 第三步
}
```

知识的诅咒，理解知识的人无法想象不理解知识的人对于知识的理解。

上述的汉诺塔问题就是一个典型的例子，

可能上面的解释还不够清晰。
现在以三层为例，人脑模拟运行。
首先明确目的，将三层从A移动到C，这事没法直接一次性搬三个过去到C，一次只能搬一个。如果是一层，那就简单了，直接将这个搬过去。这种思路怎么得出来的？事后诸葛亮来说，会者不难，难者不会。按照经验来看，复杂的事情往往没法直接下手，简单的事情可以直接做，反过来定义也可以，可以直接做的事情是简单的，没法直接做的事情是复杂的。如果有办法将复杂的事情转化为简单的事情，再完成简单的事情，那这件事就完成了。因此有两步，第一步，如何将复杂的事情转化为简单的事情，第二步，怎么做简单的事情。第二步在这里就是只有一层的情况，直接移动即可。

而问题的核心在于，将复杂的事情分解为简单的事情，在这里就是怎么从n层简化到1层，当然也没有办法直接丢掉那n-1个，然后一步到位成为只有1层。但是有办法从n层简化到n-1。
